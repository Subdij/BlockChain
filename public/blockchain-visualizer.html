<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Visualisateur de Blockchain</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
  
  <script src="/socket.io/socket.io.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: "Segoe UI", sans-serif;
    }
    
    body {
      min-height: 100vh;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 80px 20px 20px;
    }
    
    nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 1rem 2rem;
      box-shadow: 0 2px 15px rgba(0, 0, 0, 0.1);
      z-index: 1000;
    }
    
    .nav-container {
        max-width: 1200px;
        margin: 0 auto;
        display: flex;
        justify-content: flex-start;
        justify-content: center;
        align-items: center;
    }
    
    .nav-links {
      display: flex;
      gap: 2rem;
    }
    
    .nav-links a {
      color: #4a5568;
      text-decoration: none;
      font-weight: 500;
      transition: all 0.3s ease;
      position: relative;
      font-size: 1.2rem;
    }
    
    .nav-links a::after {
      content: "";
      position: absolute;
      bottom: -5px;
      left: 0;
      width: 0;
      height: 2px;
      background: #667eea;
      transition: width 0.3s ease;
    }
    
    .nav-links a:hover::after {
      width: 100%;
    }
    
    .nav-links a.active {
      color: #667eea;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    
    h1 {
      color: white;
      text-align: center;
      margin-bottom: 30px;
      font-size: 2.5rem;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 30px;
      gap: 15px;
      width: 100%;
    }
    
    .controls button {
      background: white;
      color: #4a5568;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .controls button:hover {
      background: #f0f4fd;
      transform: translateY(-2px);
      box-shadow: 0 6px 8px rgba(0, 0, 0, 0.1);
    }
    
    .controls button:active {
      transform: translateY(0);
    }
    
    .blockchain-container {
      padding: 20px 0;
      margin-bottom: 30px;
      overflow-x: auto;
      display: flex;
      justify-content: center;
      flex-direction: column;
  }
    
    .blockchain {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap; 
      gap: 25px;
      padding: 20px;
      transition: transform 0.5s ease;
      width: 100%; 
      max-width: 1200px; 
      justify-content: center;
    }
    
    .block {
      background: white;
      width: calc(25% - 25px); 
      min-width: 250px; 
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 10px 25px -3px rgba(0, 0, 0, 0.1);
      position: relative;
      transition: all 0.3s ease;
      cursor: pointer;
      
      
      
      
      opacity: 1; 
      transform: translateY(0); 
      margin-bottom: 30px; 
    }
    
    .block:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 30px -5px rgba(0, 0, 0, 0.2);
    }
    
    .block.expanded {
      width: calc(50% - 25px); 
      z-index: 10; 
      cursor: default;
    }
    
    .block.genesis {
      border: 2px solid #48bb78;
      background: linear-gradient(to bottom, white, #f0fff4);
    }
    
    .block.new {
      border: 2px solid #4299e1;
      background: linear-gradient(to bottom, white, #ebf8ff);
    }
    
    .block-header {
      border-bottom: 1px solid #e2e8f0;
      padding-bottom: 15px;
      margin-bottom: 15px;
    }
    
    .block-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .block-index {
      font-size: 1.5rem;
      font-weight: 700;
      color: #2d3748;
    }
    
    .block-timestamp {
      font-size: 0.8rem;
      color: #718096;
    }
    
    .hash-container {
      background: #f7fafc;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    
    .hash-label {
      font-size: 0.75rem;
      text-transform: uppercase;
      color: #718096;
      font-weight: 600;
      display: block;
      margin-bottom: 5px;
    }
    
    .hash-value {
      font-family: monospace;
      word-break: break-all;
      color: #2d3748;
      font-size: 0.85rem;
    }
    
    .hash-preview {
      font-family: monospace;
      color: #2d3748;
      font-size: 0.85rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .prev-hash-value {
      color: #4299e1;
      cursor: pointer;
    }
    
    .block-summary {
      display: flex;
      justify-content: space-between;
      padding: 10px 0;
    }
    
    .summary-item {
      text-align: center;
      width: 50%;
    }
    
    .summary-value {
      font-size: 1.25rem;
      font-weight: 700;
      color: #2d3748;
      margin-bottom: 5px;
    }
    
    .summary-label {
      font-size: 0.75rem;
      color: #718096;
      text-transform: uppercase;
    }
    
    .block-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.5s ease;
    }
    
    .block.expanded .block-content {
      max-height: 500px;
      overflow-y: auto;
      margin-top: 15px;
    }
    
    .transactions-label {
      font-size: 0.9rem;
      font-weight: 600;
      color: #4a5568;
      margin-bottom: 10px;
      display: block;
    }
    
    .transaction {
      background: #f0f4fd;
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      font-size: 0.85rem;
      color: #4a5568;
    }
    
    .transaction.coinbase {
      background: #c6f6d5;
      border-left: 3px solid #48bb78;
    }
    
    .transaction-details {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
      font-family: monospace;
    }
    
    .block-connect {
      position: absolute;
      right: -25px;
      top: 50%;
      transform: translateY(-50%);
      height: 2px;
      width: 25px;
      background-color: #718096;
      display: none; 
    }
    
    
    .block:not(:nth-child(4n)):not(.genesis) .block-connect {
      display: block;
    }
    
    .block-badge {
      position: absolute;
      top: -10px;
      right: -10px;
      background: #4299e1;
      color: white;
      border-radius: 50%;
      width: 25px;
      height: 25px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.8rem;
      font-weight: bold;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    }
    
    .expand-indicator {
      text-align: center;
      color: #a0aec0;
      font-size: 0.8rem;
      padding-top: 5px;
    }
    
    .block:not(.expanded) .expand-indicator {
      display: block;
    }
    
    .block.expanded .expand-indicator {
      display: none;
    }
    
    .stats {
      background: white;
      border-radius: 12px;
      padding: 20px;
      margin-top: 30px;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      width: 100%;
      max-width: 1200px;
    }
    
    .stats-title {
      font-size: 1.5rem;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 20px;
    }
    
    .stat-item {
      text-align: center;
      background: #f7fafc;
      border-radius: 8px;
      padding: 15px;
    }
    
    .stat-value {
      font-size: 1.8rem;
      font-weight: 700;
      color: #4a5568;
      margin-bottom: 5px;
    }
    
    .stat-label {
      font-size: 0.9rem;
      color: #718096;
      font-weight: 500;
    }
    
    
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(66, 153, 225, 0.5);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(66, 153, 225, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(66, 153, 225, 0);
      }
    }
    
    
    @media (max-width: 1200px) {
      .block {
        width: calc(33.33% - 25px); 
      }
      
      .block:not(:nth-child(3n)):not(.genesis) .block-connect {
        display: block;
      }
      
      .block:nth-child(3n):not(.genesis) .block-connect {
        display: none;
      }
      
      .block.expanded {
        width: calc(66.66% - 25px);
      }
    }
    
    @media (max-width: 900px) {
      .block {
        width: calc(50% - 25px); 
      }
      
      .block:not(:nth-child(2n)):not(.genesis) .block-connect {
        display: block;
      }
      
      .block:nth-child(2n):not(.genesis) .block-connect {
        display: none;
      }
      
      .block.expanded {
        width: 100%;
      }
    }
    
    @media (max-width: 600px) {
      .blockchain {
        flex-direction: column;
      }
      
      .block {
        width: 100%;
        margin-bottom: 25px;
      }
      
      .block-connect {
        left: 50%;
        top: auto;
        bottom: -25px;
        transform: translateX(-50%) rotate(90deg);
        width: 25px;
        display: block;
      }
      
      .stats-grid {
        grid-template-columns: 1fr 1fr;
      }
    }
    
    
    .loader-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 200px;
      width: 100%;
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
    }
    
    .loader {
      border: 5px solid #f3f3f3;
      border-radius: 50%;
      border-top: 5px solid #667eea;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    
    @keyframes newBlockAnimation {
      0% { transform: scale(0.8); opacity: 0; box-shadow: 0 0 0 rgba(66, 153, 225, 0.5); }
      50% { transform: scale(1.05); opacity: 1; box-shadow: 0 0 20px rgba(66, 153, 225, 0.8); }
      100% { transform: scale(1); opacity: 1; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); }
    }
    
    .block.realtime-new {
      animation: newBlockAnimation 1s forwards;
      border: 2px solid #3182ce;
    }
    
    
    .toast-notification {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(49, 130, 206, 0.9);
      color: white;
      padding: 15px 25px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      z-index: 1000;
      transform: translateY(100px);
      opacity: 0;
      transition: transform 0.4s ease, opacity 0.4s ease;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .toast-notification.show {
      transform: translateY(0);
      opacity: 1;
    }
    
    .toast-icon {
      font-size: 24px;
    }
    
    .toast-content {
      flex: 1;
    }
    
    .toast-title {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .toast-message {
      font-size: 0.9rem;
    }
    
    .logo {
      font-weight: 700;
      color: #2d3748;
      text-decoration: none;
      font-size: 1.8rem;
      transition: all 0.3s ease;
      margin-right: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      background-clip: text;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      padding: 0.2rem 1rem;

    }
    
    .logo:hover {
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <nav>
    <div class="nav-container">
      <a href="./index.html" class="logo">SUBCHAINE</a>
      <div class="nav-links">
        <a href="./SHA-256.html">SHA-256 Hash</a>
        <a href="./cryptage.html">Encrypt hash</a>
        <a href="./transaction.html">Transaction</a>
        <a href="./wallet.html">Wallet</a>
        <a href="./block.html">Mining</a>
        <a href="./blockchain-visualizer.html" class="active">Visualiser</a>
      </div>
    </div>
  </nav>
  
  <div class="container">
    <div class="stats">
        <h2 class="stats-title">Statistiques de la blockchain</h2>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value" id="blockCount">0</div>
            <div class="stat-label">Blocs</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="txCount">0</div>
            <div class="stat-label">Transactions</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="difficulty">3</div>
            <div class="stat-label">Difficult√©</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="totalValue">0 ‚Ç¨</div>
            <div class="stat-label">Valeur totale</div>
          </div>
        </div>
      </div>
    
    <div class="controls">
    </div>
    
    <div class="blockchain-container">
      <div id="loading" class="loader-container">
        <div class="loader"></div>
      </div>
      <div class="blockchain" id="blockchain">
        
      </div>
    </div>
  </div>
  
  <script>
    // Am√©lioration de la connexion socket.io avec gestion des erreurs
    let socket;
    let connected = false;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    
    // √âv√©nements du document
    document.addEventListener('DOMContentLoaded', function() {
      // Ajouter un indicateur de statut de connexion
      const controls = document.querySelector('.controls');
      const statusIndicator = document.createElement('div');
      statusIndicator.id = 'connection-status';
      statusIndicator.style.padding = '10px';
      statusIndicator.style.borderRadius = '5px';
      statusIndicator.style.marginLeft = '10px';
      statusIndicator.style.fontWeight = 'bold';
      statusIndicator.textContent = 'Connexion...';
      statusIndicator.style.background = '#f0f0f0';
      statusIndicator.style.color = '#666';
      controls.appendChild(statusIndicator);

      // Ajouter des boutons √† l'interface

      
      // Initialiser la connexion Socket.io
      initSocketConnection();
      
      // Charger la blockchain r√©elle
      loadRealBlockchain();
      
      // Ajouter les gestionnaires d'√©v√©nements
      document.getElementById('refreshBtn').addEventListener('click', loadRealBlockchain);
      document.getElementById('debugBtn').addEventListener('click', debugBlockchain);
      document.getElementById('repairBtn').addEventListener('click', repairBlockchain);
      document.getElementById('syncBtn').addEventListener('click', syncBlockchain);
      
      // Ajouter l'auto-rafra√Æchissement
      setupAutoRefresh();

      // Synchronize with the network automatically on page load
      setTimeout(() => {
        syncBlockchain();
      }, 2000); // Delay to ensure socket connection is established
    });
    
    // Fonction am√©lior√©e pour initialiser et g√©rer la connexion Socket.io
    function initSocketConnection() {
      try {
        console.log("Initialisation de la connexion Socket.io...");
        
        // Cr√©ation d'une nouvelle connexion avec options optimis√©es
        socket = io({
          reconnectionAttempts: maxReconnectAttempts,
          reconnectionDelay: 1000,
          timeout: 10000,
          transports: ['websocket', 'polling'] // WebSocket prioritaire, polling en fallback
        });
        
        // Gestion des √©v√©nements de connexion
        socket.on('connect', () => {
          console.log(`Connect√© au serveur Socket.IO (ID: ${socket.id})`);
          connected = true;
          reconnectAttempts = 0;
          updateConnectionStatus(true);
          
          // R√©initialiser les √©couteurs pour √©viter les doublons
          socket.off('blockBroadcast');
          socket.off('transactionBroadcast');
          socket.off('blockchainState');
          socket.off('clientCount');
          socket.off('fullBlockchain');
          
          // √âcouter les nouveaux blocs
          socket.on('blockBroadcast', function(newBlock) {
            console.log("Nouveau bloc re√ßu via Socket.io:", newBlock);
            handleRealtimeNewBlock(newBlock);
          });
          
          // √âcouter les nouvelles transactions pour le mempool
          socket.on('transactionBroadcast', (tx) => {
            console.log('Nouvelle transaction re√ßue dans le mempool:', tx);
            showNotification('Nouvelle transaction', `Transaction de ${tx.amount}‚Ç¨ en attente de minage`);
          });
          
          // √âcouter l'√©tat complet de la blockchain
          socket.on('blockchainState', (state) => {
            console.log('√âtat complet de la blockchain re√ßu:', state);
            document.getElementById('clientCount').textContent = state.connectedClients;
          });
          
          // √âcouter le nombre de clients connect√©s
          socket.on('clientCount', (data) => {
            console.log(`${data.count} clients connect√©s au serveur`);
            if (document.getElementById('clientCount')) {
              document.getElementById('clientCount').textContent = data.count;
            }
          });
          
          // Nouveau: √©couter les mises √† jour compl√®tes de blockchain
          socket.on('fullBlockchain', (remoteChain) => {
            console.log(`Blockchain compl√®te re√ßue du serveur (${remoteChain.length} blocs)`);
            
            // Charger notre blockchain locale
            const localChain = JSON.parse(localStorage.getItem('blockchain') || '[]');
            
            // Si la cha√Æne distante est plus longue, fusionner
            if (remoteChain.length > localChain.length) {
              const mergedChain = mergeBlockchains(localChain, remoteChain);
              localStorage.setItem('blockchain', JSON.stringify(mergedChain));
              showNotification(`Blockchain mise √† jour avec ${mergedChain.length} blocs`);
              
              // Recharger l'affichage
              loadRealBlockchain();
            }
          });
          
          // Demander l'√©tat actuel de la blockchain au serveur
          socket.emit('requestBlockchainState', {}, function(state) {
            console.log('√âtat initial re√ßu du serveur:', state);
            if (document.getElementById('clientCount')) {
              document.getElementById('clientCount').textContent = state.connectedClients;
            }
          });
          
          // Synchronisation automatique au d√©marrage
          setTimeout(() => {
            syncBlockchain();
          }, 2000);
        });
        
        // Gestion de d√©connexion et reconnexion
        socket.on('disconnect', (reason) => {
          console.log(`D√©connect√© du serveur Socket.IO (Raison: ${reason})`);
          connected = false;
          updateConnectionStatus(false, reason);
        });
        
        socket.on('reconnecting', (attemptNumber) => {
          console.log(`Tentative de reconnexion #${attemptNumber}...`);
          reconnectAttempts = attemptNumber;
          updateConnectionStatus(false, 'reconnecting', attemptNumber);
        });
        
        socket.on('reconnect_failed', () => {
          console.error(`√âchec de reconnexion apr√®s ${maxReconnectAttempts} tentatives`);
          updateConnectionStatus(false, 'failed');
        });
        
        socket.on('error', (error) => {
          console.error('Erreur Socket.IO:', error);
          updateConnectionStatus(false, 'error');
        });
      } catch (error) {
        console.error("Erreur lors de l'initialisation de Socket.io:", error);
        updateConnectionStatus(false, 'error');
      }
    }
    
    // Fonction pour mettre √† jour l'indicateur de statut de connexion
    function updateConnectionStatus(isConnected, reason = '', attempt = 0) {
      const statusIndicator = document.getElementById('connection-status');
      if (!statusIndicator) return;
      
      if (isConnected) {
        statusIndicator.textContent = 'Connect√©';
        statusIndicator.style.background = '#c6f6d5'; // Vert clair
        statusIndicator.style.color = '#22543d'; // Vert fonc√©
      } else {
        if (reason === 'reconnecting') {
          statusIndicator.textContent = `Reconnexion... (${attempt}/${maxReconnectAttempts})`;
          statusIndicator.style.background = '#feebc8'; // Jaune clair
          statusIndicator.style.color = '#7b341e'; // Orange fonc√©
        } else if (reason === 'failed') {
          statusIndicator.textContent = '√âchec de connexion';
          statusIndicator.style.background = '#fed7d7'; // Rouge clair
          statusIndicator.style.color = '#822727'; // Rouge fonc√©
        } else {
          statusIndicator.textContent = 'D√©connect√©';
          statusIndicator.style.background = '#fed7d7'; // Rouge clair
          statusIndicator.style.color = '#822727'; // Rouge fonc√©
        }
      }
    }
    
    // Fonction d√©di√©e pour g√©rer les nouveaux blocs
    function handleNewBlock(block) {
      console.log('Nouveau bloc re√ßu via Socket.io:', block);
      
      // Ajouter le bloc √† la visualisation
      try {
        // Charger la blockchain actuelle pour d√©terminer le bon index
        const currentBlockchain = JSON.parse(localStorage.getItem('blockchain') || '[]');
        
        // V√©rifier si ce bloc existe d√©j√† par hash (crit√®re unique)
        const existingBlockByHash = document.querySelector(`.block[data-hash="${block.hash}"]`);
        if (existingBlockByHash) {
          console.log(`Le bloc avec hash ${block.hash.substring(0,8)}... existe d√©j√†, pas besoin de l'ajouter √† nouveau`);
          return;
        }
        
        // Si un bloc avec le m√™me index existe d√©j√† mais hash diff√©rent, c'est un fork possible
        const existingBlockByIndex = document.getElementById(`block-${block.index}`);
        if (existingBlockByIndex) {
          console.log(`Un bloc avec index ${block.index} existe d√©j√† mais avec un hash diff√©rent. Possible fork d√©tect√©.`);
          // Pour notre visualiseur simple, nous afficherons les deux blocs en cas de fork
        }
        
        // V√©rifier si l'index est d√©fini et coh√©rent
        if (typeof block.index === 'undefined') {
          const blockchainContainer = document.getElementById('blockchain');
          if (blockchainContainer.children.length > 0) {
            block.index = parseInt(blockchainContainer.children[0].getAttribute('data-index')) + 1;
          } else {
            block.index = 0;
          }
        }
        
        // CORRECTION: Attribuer le bon index au bloc
        block.index = currentBlockchain.length;
        
        // D√©terminer si c'est un bloc de gen√®se
        const isGenesis = block.index === 0;
        
        // S'assurer que le Merkle Root est d√©fini
        if (!block.merkleRoot) {
          console.log("Calcul du Merkle Root pour le bloc re√ßu...");
          // Cr√©er un objet Block temporaire pour calculer le Merkle Root
          const tempBlock = new Block(
            block.index,
            block.previousHash,
            block.transactions
          );
          block.merkleRoot = tempBlock.calculateMerkleRoot();
        }
        
        // Ajouter le bloc √† la visualisation avec l'animation "nouveau"
        addBlockToVisualizer(block, isGenesis, true);
        
        // Mettre √† jour les statistiques
        updateStats();
        
        // Stocker le bloc dans localStorage
        updateLocalStorage(block);
        
        // Afficher une notification pour informer l'utilisateur
        showNotification(`Nouveau bloc #${block.index} avec hash ${block.hash.substring(0,8)}... ajout√© √† la cha√Æne`);
        
        // Recharger les blocs apr√®s un court d√©lai pour assurer un affichage coh√©rent
        setTimeout(() => {
          checkBlockConnections();
        }, 500);
      } catch (error) {
        console.error('Erreur lors du traitement du nouveau bloc:', error);
      }
    }
    
    // Fonction pour mettre √† jour localStorage avec le nouveau bloc
    function updateLocalStorage(newBlock) {
      try {
        const currentBlockchain = JSON.parse(localStorage.getItem('blockchain') || '[]');
        
        // V√©rifier si le bloc existe d√©j√† par son hash uniquement (crit√®re unique)
        const blockExists = currentBlockchain.some(block => block.hash === newBlock.hash);
        
        if (!blockExists) {
          // CORRECTION: Attribuer le bon index au bloc avant de l'ajouter
          newBlock.index = currentBlockchain.length;
          
          // Ajouter le bloc
          currentBlockchain.push(newBlock);
          
          // Sauvegarder dans localStorage
          localStorage.setItem('blockchain', JSON.stringify(currentBlockchain));
          console.log(`Bloc #${newBlock.index} (hash ${newBlock.hash.substring(0,8)}...) ajout√© √† localStorage`);
        } else {
          console.log(`Bloc ${newBlock.hash.substring(0,8)}... existe d√©j√† dans localStorage`);
        }
      } catch (error) {
        console.error("Erreur lors de la mise √† jour de la blockchain dans localStorage:", error);
      }
    }
    
    // Fonction pour afficher une notification temporaire
    function showNotification(message) {
      const notification = document.createElement('div');
      notification.textContent = message;
      notification.style.position = 'fixed';
      notification.style.bottom = '20px';
      notification.style.right = '20px';
      notification.style.background = 'rgba(0, 0, 0, 0.8)';
      notification.style.color = 'white';
      notification.style.padding = '10px 20px';
      notification.style.borderRadius = '5px';
      notification.style.zIndex = '1000';
      notification.style.transition = 'opacity 0.5s';
      
      document.body.appendChild(notification);
      
      setTimeout(() => {
        notification.style.opacity = '0';
        setTimeout(() => notification.remove(), 500);
      }, 3000);
    }

    // Fonction am√©lior√©e pour charger la blockchain r√©elle depuis localStorage
    function loadRealBlockchain() {
      // Afficher le loader
      document.getElementById('loading').style.display = 'flex';
      document.getElementById('blockchain').innerHTML = '';
      
      setTimeout(() => {
        try {
          // Essayer de charger la blockchain depuis diff√©rents emplacements possibles
          let blockchain = [];
          
          // Essayer de charger depuis 'blockchain'
          const blockchainData = localStorage.getItem('blockchain');
          if (blockchainData) {
            blockchain = JSON.parse(blockchainData);
            console.log("Blockchain charg√©e depuis 'blockchain' :", blockchain);
          }
          
          // Si pas de donn√©es, essayer 'myBlockchain'
          if (!blockchain || blockchain.length === 0) {
            const myBlockchainData = localStorage.getItem('myBlockchain');
            if (myBlockchainData) {
              const parsed = JSON.parse(myBlockchainData);
              if (parsed && parsed.chain && Array.isArray(parsed.chain)) {
                blockchain = parsed.chain;
                console.log("Blockchain charg√©e depuis 'myBlockchain.chain' :", blockchain);
              }
            }
          }
          
          // Si toujours pas de donn√©es, cr√©er un bloc de gen√®se
          if (!blockchain || blockchain.length === 0) {
            blockchain = [createGenesisBlock()];
            localStorage.setItem('blockchain', JSON.stringify(blockchain));
            console.log("Blockchain vide, cr√©ation d'un bloc de gen√®se");
          }
          
          console.log(`Blockchain charg√©e: ${blockchain.length} blocs`);

          // AJOUT: V√©rification automatique de l'int√©grit√© de la blockchain
          const repairNeeded = verifyBlockchainIntegrity(blockchain);
          
          // Si la blockchain a besoin de r√©paration, la r√©parer automatiquement
          if (repairNeeded) {
            console.log("Incoh√©rences d√©tect√©es dans la blockchain, r√©paration automatique...");
            blockchain = repairBlockchainData(blockchain);
            // Sauvegarder la blockchain r√©par√©e
            localStorage.setItem('blockchain', JSON.stringify(blockchain));
            showNotification("La blockchain a √©t√© r√©par√©e automatiquement pour corriger des incoh√©rences");
          }
          
          blockchain.forEach((block, idx) => {
            console.log(`Bloc #${idx}: Hash=${block.hash?.substring(0,8)}..., ${block.transactions?.length || 0} transactions`);
          });
          
          // Masquer le loader
          document.getElementById('loading').style.display = 'none';
          
          // Effacer le contenu actuel
          const blockchainContainer = document.getElementById('blockchain');
          blockchainContainer.innerHTML = '';
          
          // Trier les blocs par index si n√©cessaire
          blockchain.sort((a, b) => (a.index || 0) - (b.index || 0));
          
          // CORRECTION: S'assurer que tous les blocs ont des index corrects et s√©quentiels
          blockchain = blockchain.map((block, index) => {
            block.index = index; // Forcer l'index √† √™tre s√©quentiel
            return block;
          });
          
          // Sauvegarder la blockchain corrig√©e
          localStorage.setItem('blockchain', JSON.stringify(blockchain));
          
          // Configurer le conteneur pour le centrage
          blockchainContainer.style.overflowX = 'auto';
          blockchainContainer.style.padding = '20px';
          blockchainContainer.style.width = '100%';
          blockchainContainer.style.display = 'flex';
          blockchainContainer.style.justifyContent = 'center';
          
          // Ajouter chaque bloc avec un d√©lai pour l'animation (du plus r√©cent au plus ancien)
          // Nous parcourons la cha√Æne dans son ordre normal (du plus ancien au plus r√©cent)
          blockchain.forEach((block, index) => {
            // Assigner un index si manquant
            if (typeof block.index === 'undefined') {
              block.index = index;
            }
            
            const isGenesis = block.index === 0;
            // Ajouter le bloc imm√©diatement sans d√©lai
            addBlockToVisualizer(block, isGenesis, index === blockchain.length - 1);
            
            // Mettre √† jour les statistiques apr√®s avoir ajout√© le dernier bloc
            if (index === blockchain.length - 1) {
              updateStats(blockchain);
              
              // Ajouter une notification pour indiquer le nombre de blocs charg√©s
              showNotification(`${blockchain.length} blocs charg√©s avec succ√®s`);
            }
          });
          
        } catch (error) {
          console.error("Erreur lors du chargement de la blockchain:", error);
          document.getElementById('loading').style.display = 'none';
          alert(`Erreur lors du chargement de la blockchain: ${error.message}. Une blockchain simul√©e sera utilis√©e.`);
          
          // En cas d'erreur, cr√©er un genesis block
          const blockchainContainer = document.getElementById('blockchain');
          blockchainContainer.innerHTML = '';
          
          const genesisBlock = createGenesisBlock();
          addBlockToVisualizer(genesisBlock, true);
          updateStats([genesisBlock]);
        }
      }, 500); // Petit d√©lai pour montrer le loader
    }
    
    // AJOUT: Fonction pour v√©rifier l'int√©grit√© de la blockchain
    function verifyBlockchainIntegrity(blockchain) {
      if (!blockchain || blockchain.length <= 1) return false;
      
      let needsRepair = false;
      
      // V√©rifier si les index sont s√©quentiels et si les hash pr√©c√©dents correspondent
      for (let i = 1; i < blockchain.length; i++) {
        const currentBlock = blockchain[i];
        const prevBlock = blockchain[i-1];
        
        // V√©rifier l'index
        if (currentBlock.index !== i) {
          console.log(`Erreur d'index pour le bloc #${i}, index stock√©: ${currentBlock.index}`);
          needsRepair = true;
        }
        
        // V√©rifier le hash pr√©c√©dent
        if (currentBlock.previousHash !== prevBlock.hash) {
          console.log(`Erreur de hash pour le bloc #${i}:`);
          console.log(`  Hash pr√©c√©dent stock√©: ${currentBlock.previousHash?.substring(0,20) || 'undefined'}`);
          console.log(`  Hash r√©el du bloc pr√©c√©dent: ${prevBlock.hash?.substring(0,20) || 'undefined'}`);
          needsRepair = true;
        }
      }
      
      return needsRepair;
    }
    
    // AJOUT: Fonction pour r√©parer automatiquement la blockchain
    function repairBlockchainData(blockchain) {
      if (!blockchain || blockchain.length <= 1) return blockchain;
      
      // 1. S'assurer que les index sont s√©quentiels
      blockchain = blockchain.map((block, index) => {
        block.index = index;
        return block;
      });
      
      // 2. Reconstruire les r√©f√©rences de hash
      for (let i = 1; i < blockchain.length; i++) {
        blockchain[i].previousHash = blockchain[i-1].hash;
      }
      
      console.log("Blockchain r√©par√©e avec succ√®s");
      return blockchain;
    }
    
    // Fonction pour cr√©er un bloc de gen√®se si n√©cessaire
    function createGenesisBlock() {
      return {
        index: 0,
        timestamp: new Date().toISOString(),
        transactions: [],
        previousHash: "0",
        hash: CryptoJS.SHA256("Genesis Block").toString(),
        nonce: 0
      };
    }
    
    // Fonction am√©lior√©e pour ajouter un bloc √† la visualisation
    function addBlockToVisualizer(block, isGenesis = false, isNew = false) {
      const blockchainContainer = document.getElementById('blockchain');
      
      // V√©rifier si les propri√©t√©s n√©cessaires sont pr√©sentes
      if (!block.index && block.index !== 0) block.index = blockchainContainer.children.length;
      if (!block.timestamp) block.timestamp = new Date().toISOString();
      if (!block.hash) block.hash = "hash_manquant_" + Math.random().toString(36).substring(2, 15);
      if (!block.previousHash) block.previousHash = "0";
      if (!block.transactions) block.transactions = [];
      
      // Cr√©er l'√©l√©ment de bloc
      const blockElement = document.createElement('div');
      blockElement.className = `block ${isGenesis ? 'genesis' : ''} ${isNew ? 'new' : ''}`;
      blockElement.setAttribute('data-index', block.index);
      blockElement.setAttribute('data-hash', block.hash);
      blockElement.setAttribute('data-prev-hash', block.previousHash);
      blockElement.setAttribute('id', `block-${block.index}`);
      
      // Calculer le nombre de transactions
      const txCount = block.transactions ? block.transactions.length : 0;
      
      // Trouver la transaction coinbase et calculer la r√©compense
      let reward = 0;
      if (block.transactions && block.transactions.length > 0) {
        // Chercher la transaction coinbase (premi√®re transaction ou marqu√©e coinbase)
        const coinbaseTx = block.transactions.find(tx => 
          tx.coinbase === true || tx.from === 'COINBASE' || 
          // Aussi v√©rifier la premi√®re transaction si aucune n'est explicitement marqu√©e
          (tx === block.transactions[0] && (tx.from === 'COINBASE' || tx.from === 'R√©compense'))
        );
        
        if (coinbaseTx) {
          // S'assurer que la r√©compense est toujours un nombre
          reward = parseFloat(coinbaseTx.amount || "0");
          
          // Correction: si nous sommes dans un bloc normal (non genesis) et la r√©compense est 0,
          // attribuer la r√©compense de base de 50‚Ç¨
          if (!isGenesis && (reward === 0 || isNaN(reward)) && block.index > 0) {
            reward = 50; // R√©compense de base par d√©faut
            console.log(`Correction de la r√©compense pour le bloc #${block.index}: ${reward}‚Ç¨`);
          }
        } else if (!isGenesis && block.index > 0) {
          // Si on ne trouve pas de transaction coinbase mais c'est un bloc normal, 
          // utiliser la r√©compense par d√©faut de 50‚Ç¨
          reward = 50;
          console.log(`R√©compense par d√©faut pour bloc #${block.index}: ${reward}‚Ç¨`);
        }
      }
      
      // Badge pour le nombre de transactions
      if (txCount > 0) {
        blockElement.innerHTML += `<div class="block-badge">${txCount}</div>`;
      }
      
      // Ligne connectant au bloc pr√©c√©dent (sauf pour genesis)
      if (!isGenesis) {
        blockElement.innerHTML += `<div class="block-connect"></div>`;
      }
      
      // En-t√™te du bloc avec informations essentielles
      blockElement.innerHTML += `
        <div class="block-header">
          <div class="block-title">
            <div class="block-index">Bloc #${block.index}</div>
            <div class="block-timestamp">${new Date(block.timestamp).toLocaleDateString()} ${new Date(block.timestamp).toLocaleTimeString()}</div>
          </div>
          
          <div class="hash-container">
            <span class="hash-label">Hash</span>
            <div class="hash-preview">${block.hash.substring(0, 20)}...</div>
          </div>
        </div>
        
        <div class="block-summary">
          <div class="summary-item">
            <div class="summary-value">${txCount}</div>
            <div class="summary-label">Transactions</div>
          </div>
          <div class="summary-item">
            <div class="summary-value">${reward} ‚Ç¨</div>
            <div class="summary-label">R√©compense</div>
          </div>
        </div>
        
        <div class="expand-indicator">Cliquez pour voir les d√©tails</div>
          
          <div class="block-content">
            <div class="hash-container">
              <span class="hash-label">Hash complet</span>
              <div class="hash-value">${block.hash}</div>
            </div>
            
            <div class="hash-container">
              <span class="hash-label">Hash pr√©c√©dent</span>
              <div class="hash-value prev-hash-value" onclick="event.stopPropagation(); highlightBlock('${block.previousHash}')">${block.previousHash}</div>
            </div>
            
            <div class="hash-container">
              <span class="hash-label">Nonce</span>
              <div class="hash-value">${block.nonce || 0}</div>
            </div>
            
            <div class="transactions-label">Transactions (${txCount})</div>
            <div class="transactions-list">
          `;
          
          // Ajouter les transactions
          if (block.transactions && block.transactions.length > 0) {
            block.transactions.forEach(tx => {
              const isCoinbase = tx.coinbase || tx.from === "COINBASE";
              
              blockElement.querySelector('.transactions-list').innerHTML += `
                <div class="transaction ${isCoinbase ? 'coinbase' : ''}">
                  ${isCoinbase ? 
                    `<div class="transaction-details">
                      <span>R√©compense de minage</span>
                      <span>${tx.amount} ‚Ç¨</span>
                    </div>
                    <div>‚Üí ${formatAddress(tx.to)}</div>` : 
                    `<div class="transaction-details">
                      <span>Transfert</span>
                      <span>${tx.amount} ‚Ç¨ + ${tx.fee || '0'} ‚Ç¨ frais</span>
                    </div>
                    <div>${formatAddress(tx.from)} ‚Üí ${formatAddress(tx.to)}</div>`
                  }
                </div>
              `;
            });
          } else {
            blockElement.querySelector('.transactions-list').innerHTML = `<p>Aucune transaction dans ce bloc</p>`;
          }
          
          // Ajouter le Merkle Root dans la section d√©tails du bloc
          blockElement.querySelector('.block-content').innerHTML += `
            <div class="hash-container">
              <span class="hash-label">Merkle Root</span>
              <div class="hash-value">${block.merkleRoot || "Non disponible"}</div>
            </div>
          `;
          
          blockElement.innerHTML += `</div>`;
          
          // Ajouter l'√©v√©nement de clic pour √©tendre/r√©duire
          blockElement.addEventListener('click', function() {
            toggleBlockDetails(this);
          });
          
          // Ajouter le bloc au d√©but du conteneur
          if (blockchainContainer.firstChild) {
            blockchainContainer.insertBefore(blockElement, blockchainContainer.firstChild);
          } else {
            blockchainContainer.appendChild(blockElement);
          }
          
          // Faire d√©filer vers le nouveau bloc avec une animation fluide
          blockElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          
          return blockElement;
        }
        
        // Fonction pour sauvegarder le bloc dans localStorage
        function saveBlockLocally(block) {
          try {
            const blockchainData = localStorage.getItem('blockchain');
            let blockchain = blockchainData ? JSON.parse(blockchainData) : [];
            
            // V√©rifier si le bloc existe d√©j√†
            const blockExists = blockchain.some(existingBlock => existingBlock.hash === block.hash);
            
            if (!blockExists) {
              // Assurer que l'index est correct
              block.index = blockchain.length;
              
              // Ajouter le bloc
              blockchain.push(block);
              localStorage.setItem('blockchain', JSON.stringify(blockchain));
              console.log(`Bloc #${block.index} sauvegard√© dans localStorage`);
            }
          } catch (error) {
            console.error("Erreur lors de la sauvegarde du bloc:", error);
          }
        }
        
        // Fonction pour afficher une notification pour le nouveau bloc
        function showBlockNotification(block) {
          // Cr√©er l'√©l√©ment de notification
          let notification = document.getElementById('block-notification');
          if (!notification) {
            notification = document.createElement('div');
            notification.id = 'block-notification';
            notification.className = 'toast-notification';
            
            notification.innerHTML = `
              <div class="toast-icon">üß±</div>
              <div class="toast-content">
                <div class="toast-title">Nouveau bloc re√ßu</div>
                <div class="toast-message" id="toast-message"></div>
              </div>
            `;
            
            document.body.appendChild(notification);
          }
          
          // Mettre √† jour le contenu
          const messageEl = document.getElementById('toast-message');
          if (messageEl) {
            messageEl.textContent = `Bloc #${block.index} avec ${block.transactions?.length || 0} transactions vient d'√™tre ajout√© √† la blockchain`;
          }
          
          // Afficher la notification
          notification.classList.add('show');
          
          // Cacher la notification apr√®s 5 secondes
          setTimeout(() => {
            notification.classList.remove('show');
          }, 5000);
        }
        
        // Modifier la fonction setupAutoRefresh pour √™tre plus efficace
        function setupAutoRefresh() {
          // V√©rification p√©riodique de la connexion avec le serveur
          setInterval(() => {
            if (connected) {
              // Heartbeat pour v√©rifier la latence et maintenir la connexion
              socket.emit('heartbeat', (response) => {
                const latency = new Date() - new Date(response.serverTime);
                console.log(`Connexion au serveur: OK (latence ${latency}ms)`);
              });
            }
          }, 30000); // Toutes les 30 secondes
          
          // V√©rification locale des blocs dans localStorage moins fr√©quente
          setInterval(() => {
            try {
              const blockchainData = localStorage.getItem('blockchain');
              if (!blockchainData) return;
              
              const blockchain = JSON.parse(blockchainData);
              const displayedBlockCount = document.querySelectorAll('.block').length;
              
              // Si le nombre de blocs dans localStorage est diff√©rent du nombre affich√©,
              // ajouter uniquement les blocs manquants sans recharger toute la page
              if (blockchain.length > displayedBlockCount) {
                console.log(`${blockchain.length - displayedBlockCount} nouveau(x) bloc(s) d√©tect√©(s) en stockage local`);
                
                // Identifier les blocs manquants
                const displayedHashes = Array.from(document.querySelectorAll('.block'))
                  .map(el => el.getAttribute('data-hash'));
                
                // Ajouter uniquement les blocs manquants
                blockchain.forEach(block => {
                  if (!displayedHashes.includes(block.hash)) {
                    console.log(`Ajout du bloc local #${block.index} (${block.hash.substring(0, 8)}...)`);
                    handleRealtimeNewBlock(block, false); // false = pas d'animation
                  }
                });
                
                // Mettre √† jour les statistiques
                updateStats();
              }
            } catch (error) {
              console.error("Erreur lors de la v√©rification auto-refresh:", error);
            }
          }, 5000); // Toutes les 5 secondes
        }
    
    // Nouvelle fonction pour v√©rifier et ajuster les connexions entre les blocs
    function checkBlockConnections() {
      const blocks = document.querySelectorAll('.block');
      const blockArray = Array.from(blocks);
      
      // R√©initialiser tous les connecteurs
      blocks.forEach(block => {
        const connector = block.querySelector('.block-connect');
        if (connector) {
          connector.style.display = 'none';
        }
      });
      
      // Pour chaque bloc (sauf le dernier)
      for (let i = 0; i < blockArray.length - 1; i++) {
        const block = blockArray[i];
        const nextBlock = blockArray[i + 1];
        
        // Si le bloc suivant fait r√©f√©rence √† ce bloc via previousHash
        if (nextBlock.getAttribute('data-prev-hash') === block.getAttribute('data-hash')) {
          const connector = block.querySelector('.block-connect');
          
          // V√©rifier si les blocs sont sur la m√™me ligne (4 blocs par ligne)
          const blockRect = block.getBoundingClientRect();
          const nextBlockRect = nextBlock.getBoundingClientRect();
          
          // Si les blocs sont aproximativement sur la m√™me ligne (tol√©rance de 50px)
          if (Math.abs(blockRect.top - nextBlockRect.top) < 50) {
            if (connector) {
              connector.style.display = 'block';
              connector.style.right = '-25px';
              connector.style.top = '50%';
              connector.style.transform = 'translateY(-50%)';
              connector.style.width = '25px';
              connector.style.height = '2px';
            }
          } else {
            // Connection verticale si les blocs sont sur des lignes diff√©rentes
            if (connector) {
              connector.style.display = 'block';
              connector.style.right = '50%';
              connector.style.top = '100%';
              connector.style.transform = 'translateX(50%)';
              connector.style.width = '2px';
              connector.style.height = '25px';
            }
          }
        }
      }
    }
    
    // Fonction pour formater les adresses
    function formatAddress(address) {
      if (!address) return 'Adresse inconnue';
      if (address === 'COINBASE') return 'COINBASE';
      if (address.length > 20) {
        return `${address.substring(0, 10)}...${address.substring(address.length - 4)}`;
      }
      return address;
    }
    
    // Fonction pour basculer l'affichage d√©taill√© d'un bloc
    function toggleBlockDetails(blockElement) {
      // Fermer tous les autres blocs ouverts
      document.querySelectorAll('.block.expanded').forEach(el => {
        if (el !== blockElement) {
          el.classList.remove('expanded');
        }
      });
      
      // Basculer l'√©tat du bloc actuel
      blockElement.classList.toggle('expanded');
    }
    
    // Fonction pour mettre en √©vidence un bloc en fonction de son hash
    function highlightBlock(hash) {
      if (hash === "0") return; // Ignorer le hash du genesis block
      
      const blocks = document.querySelectorAll('.block');
      let found = false;
      
      blocks.forEach(block => {
        if (block.getAttribute('data-hash') === hash) {
          // D√©filer vers le bloc
          block.scrollIntoView({behavior: 'smooth', block: 'center'});
          
          // Effet de mise en surbrillance
          const originalBackground = block.style.background;
          block.style.background = '#fef3c7';
          
          setTimeout(() => {
            block.style.background = originalBackground;
          }, 2000);
          
          found = true;
        }
      });
      
      if (!found) {
        alert("Bloc non trouv√© dans la cha√Æne visualis√©e. Il pourrait appartenir √† une cha√Æne diff√©rente ou √™tre hors de la vue actuelle.");
      }
    }
    
    // Fonction pour mettre √† jour les statistiques
    function updateStats(blockchain) {
      let totalBlocks = 0;
      let totalTx = 0;
      let difficulty = 3;
      let totalValue = 0;
      
      if (blockchain) {
        totalBlocks = blockchain.length;
        
        blockchain.forEach(block => {
          if (block.transactions) {
            totalTx += block.transactions.length;
            
            // Calculer la valeur totale des transactions
            block.transactions.forEach(tx => {
              if (tx.amount) {
                totalValue += parseFloat(tx.amount);
              }
            });
          }
        });
        
        // Essayer de r√©cup√©rer la difficult√©
        try {
          difficulty = parseInt(localStorage.getItem('blockchainDifficulty')) || 3;
        } catch (e) {
          console.log("Difficult√© par d√©faut utilis√©e");
        }
      } else {
        // Si pas de blockchain fournie, compter les blocs affich√©s
        totalBlocks = document.querySelectorAll('.block').length;
        
        document.querySelectorAll('.block').forEach(block => {
          const txCountEl = block.querySelector('.summary-value');
          if (txCountEl) {
            totalTx += parseInt(txCountEl.textContent);
          }
        });
      }
      
      document.getElementById('blockCount').textContent = totalBlocks;
      document.getElementById('txCount').textContent = totalTx;
      document.getElementById('difficulty').textContent = difficulty;
      document.getElementById('totalValue').textContent = `${totalValue.toFixed(2)} ‚Ç¨`;
    }
    
    // √âcouter les √©v√©nements socket pour les mises √† jour en temps r√©el
    socket.on('blockBroadcast', (newBlock) => {
      console.log("Nouveau bloc re√ßu:", newBlock);
      
      // Ajouter le nouveau bloc au d√©but de la cha√Æne
      const blockchainContainer = document.getElementById('blockchain');
      if (blockchainContainer.children.length > 0) {
        // S'assurer que le nouvel index est correct
        if (typeof newBlock.index === 'undefined') {
          newBlock.index = parseInt(blockchainContainer.children[0].getAttribute('data-index')) + 1;
        }
      }
      
      // Ajouter le bloc √† la visualisation en tant que "nouveau"
      addBlockToVisualizer(newBlock, newBlock.index === 0, true);
      
      // Mettre √† jour les statistiques
      const currentBlocks = parseInt(document.getElementById('blockCount').textContent);
      document.getElementById('blockCount').textContent = currentBlocks + 1;
      
      // Enregistrer dans localStorage
      try {
        const currentBlockchain = JSON.parse(localStorage.getItem('blockchain') || '[]');
        currentBlockchain.push(newBlock);
        localStorage.setItem('blockchain', JSON.stringify(currentBlockchain));
      } catch (error) {
        console.error("Erreur lors de la mise √† jour de la blockchain dans localStorage:", error);
      }
    });
    
    // √âcouter les redimensionnements de la fen√™tre pour ajuster les connexions
    window.addEventListener('resize', debounce(function() {
      checkBlockConnections();
    }, 250));
    
    // Fonction utilitaire pour limiter les appels fr√©quents (debounce)
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // Ajoutons un bouton pour d√©boguer la blockchain
    document.addEventListener('DOMContentLoaded', function() {
      // Ajouter le bouton de d√©bogage apr√®s le bouton de rafra√Æchissement
      const controls = document.querySelector('.controls');
      
      const debugButton = document.createElement('button');
      debugButton.textContent = 'D√©boguer la blockchain';
      debugButton.addEventListener('click', debugBlockchain);
      controls.appendChild(debugButton);
    });
    
    // Fonction de d√©bogage pour afficher des informations d√©taill√©es sur la blockchain
    function debugBlockchain() {
      try {
        // R√©cup√©rer la blockchain depuis localStorage
        const blockchainData = localStorage.getItem('blockchain');
        if (!blockchainData) {
          alert("Aucune blockchain trouv√©e dans localStorage.");
          return;
        }
        
        const blockchain = JSON.parse(blockchainData);
        
        // Cr√©er un message de d√©bogage format√©
        let message = `== D√âBOGAGE BLOCKCHAIN ==\nNombre de blocs: ${blockchain.length}\n\n`;
        let hasErrors = false;
        
        blockchain.forEach((block, index) => {
          message += `BLOC #${block.index || index}\n`;
          message += `- Index stock√©: ${block.index}\n`;
          message += `- Hash: ${block.hash?.substring(0, 20)}...\n`;
          message += `- Hash pr√©c√©dent: ${block.previousHash?.substring(0, 20)}...\n`;
          message += `- Transactions: ${block.transactions?.length || 0}\n`;
          
          // V√©rifier si l'index est correct
          if (block.index !== index) {
            message += `‚ö†Ô∏è ERREUR: Index incorrect (stock√©: ${block.index}, attendu: ${index})\n`;
            hasErrors = true;
          }
          
          // V√©rifier la coh√©rence du previous hash (sauf pour le bloc genesis)
          if (index > 0) {
            const previousBlock = blockchain[index - 1];
            if (block.previousHash !== previousBlock.hash) {
              message += `‚ö†Ô∏è ERREUR: Le hash pr√©c√©dent ne correspond pas au hash du bloc pr√©c√©dent\n`;
              hasErrors = true;
            }
          }
          
          message += `\n`;
        });
        
        if (hasErrors) {
          message += `\n‚ö†Ô∏è Des erreurs ont √©t√© d√©tect√©es. Utilisez le bouton 'R√©parer les index' pour tenter une correction.`;
        } else {
          message += `\n‚úÖ Aucune erreur d√©tect√©e. La blockchain est int√®gre.`;
        }
        
        // Afficher le message
        console.log(message);
        alert(message);
        
        // Si des erreurs sont d√©tect√©es, proposer de r√©parer automatiquement
        if (hasErrors && confirm("Des erreurs ont √©t√© d√©tect√©es dans la blockchain. Voulez-vous tenter une r√©paration automatique?")) {
          repairBlockchain();
        } else {
          // Relancer le chargement de la blockchain 
          document.querySelectorAll('.block').forEach(block => {
            block.style.animation = 'pulse 1s infinite';
          });
          
          setTimeout(() => {
            loadRealBlockchain();
          }, 1000);
        }
        
      } catch (error) {
        alert(`Erreur lors du d√©bogage: ${error.message}`);
        console.error(error);
      }
    }

    // Am√©liorer la r√©activit√© du visualisateur
    window.addEventListener('load', function() {
      // Force une relecture apr√®s chargement complet
      setTimeout(checkBlockConnections, 1000);
    });
    
    // Ajouter une fonction d'auto-rafra√Æchissement pour s'assurer que les blocs min√©s r√©cemment sont affich√©s
    function setupAutoRefresh() {
      // V√©rifier plus fr√©quemment s'il y a de nouveaux blocs dans localStorage
      setInterval(() => {
        try {
          const blockchainData = localStorage.getItem('blockchain');
          if (!blockchainData) return;
          
          const blockchain = JSON.parse(blockchainData);
          const displayedBlockCount = document.querySelectorAll('.block').length;
          
          // Si le nombre de blocs dans localStorage est diff√©rent du nombre affich√©,
          // rafra√Æchir l'affichage
          if (blockchain.length !== displayedBlockCount) {
            console.log(`Auto-refresh: ${blockchain.length} blocs en stockage, ${displayedBlockCount} affich√©s`);
            loadRealBlockchain();
          }
        } catch (error) {
          console.error("Erreur lors de la v√©rification auto-refresh:", error);
        }
      }, 5000); // V√©rifier toutes les 5 secondes (r√©duit de 10 √† 5 secondes)
    }

    // Ajouter un bouton pour r√©parer les index de la blockchain
    document.addEventListener('DOMContentLoaded', function() {
      const controls = document.querySelector('.controls');
      
      // Ajouter un bouton de r√©paration apr√®s le bouton de d√©bogage
      const repairButton = document.createElement('button');
      repairButton.textContent = 'R√©parer les index';
      repairButton.style.background = 'linear-gradient(135deg, #ed8936 0%, #dd6b20 100%)';
      repairButton.addEventListener('click', repairBlockchain);
      controls.appendChild(repairButton);
    });

    // Fonction pour r√©parer la blockchain (version am√©lior√©e)
    function repairBlockchain() {
      try {
        // R√©cup√©rer la blockchain depuis localStorage
        const blockchainData = localStorage.getItem('blockchain');
        if (!blockchainData) {
          alert("Aucune blockchain trouv√©e dans localStorage √† r√©parer.");
          return;
        }
        
        let blockchain = JSON.parse(blockchainData);
        if (!blockchain || !Array.isArray(blockchain) || blockchain.length === 0) {
          alert("Format de blockchain invalide ou vide.");
          return;
        }
        
        // Afficher des informations avant r√©paration
        console.log(`R√©paration de la blockchain commenc√©e. ${blockchain.length} blocs √† v√©rifier.`);
        
        // 1. V√©rifier et corriger les index s√©quentiels
        let modified = false;
        
        blockchain = blockchain.map((block, index) => {
          if (block.index !== index) {
            console.log(`Correction de l'index du bloc ${block.index} -> ${index}`);
            block.index = index;
            modified = true;
          }
          return block;
        });
        
        // 2. V√©rifier et corriger les r√©f√©rences previousHash
        for (let i = 1; i < blockchain.length; i++) {
          const currentBlock = blockchain[i];
          const previousBlock = blockchain[i - 1];
          
          // CORRECTION: Toujours mettre √† jour le previousHash pour assurer la coh√©rence
          if (currentBlock.previousHash !== previousBlock.hash) {
            console.log(`Correction de la r√©f√©rence previousHash du bloc #${i}:`);
            console.log(`  Ancien: ${currentBlock.previousHash?.substring(0, 15) || 'undefined'}...`);
            console.log(`  Nouveau: ${previousBlock.hash?.substring(0, 15) || 'undefined'}...`);
            
            // Corriger la r√©f√©rence
            currentBlock.previousHash = previousBlock.hash;
            modified = true;
          }
        }
        
        if (modified) {
          // Sauvegarder la blockchain r√©par√©e
          localStorage.setItem('blockchain', JSON.stringify(blockchain));
          console.log("R√©paration termin√©e et sauvegard√©e.");
          
          // Recharger la visualisation
          showNotification("Blockchain r√©par√©e avec succ√®s! Rechargement...");
          setTimeout(() => {
            loadRealBlockchain();
          }, 1500);
        } else {
          console.log("Aucune correction n√©cessaire. La blockchain est int√®gre.");
          showNotification("La blockchain est d√©j√† en bon √©tat. Aucune r√©paration n√©cessaire.");
        }
        
      } catch (error) {
        console.error('Erreur lors de la r√©paration de la blockchain:', error);
        alert(`Erreur lors de la r√©paration: ${error.message}`);
      }
    }
    
    // Modification de la fonction d'initialisation Socket.io pour renforcer la r√©ception des blocs
    function initSocketConnection() {
      // Cr√©ation d'une nouvelle connexion
      socket = io({
        reconnectionAttempts: maxReconnectAttempts,
        timeout: 10000,
        reconnectionDelay: 1000
      });
      
      // Gestion des √©v√©nements de connexion
      socket.on('connect', () => {
        console.log(`Connect√© au serveur Socket.IO (ID: ${socket.id})`);
        connected = true;
        reconnectAttempts = 0;
        updateConnectionStatus(true);
        
        // R√©initialiser tous les gestionnaires d'√©v√©nements pour √©viter les doublons
        socket.off('blockBroadcast');
        
        // D√©placer cette √©coute √† l'int√©rieur de l'√©v√©nement connect
        socket.on('blockBroadcast', function(newBlock) {
          console.log("Nouveau bloc re√ßu via Socket.io en temps r√©el:", newBlock);
          
          // Utiliser la fonction am√©lior√©e pour g√©rer les nouveaux blocs
          handleRealtimeNewBlock(newBlock);
        });
        
        // ...existing code...
      });
      
      socket.on('disconnect', (reason) => {
        console.log(`D√©connect√© du serveur Socket.IO (Raison: ${reason})`);
        connected = false;
        updateConnectionStatus(false, reason);
      });
      
      socket.on('reconnecting', (attemptNumber) => {
        console.log(`Tentative de reconnexion #${attemptNumber}...`);
        reconnectAttempts = attemptNumber;
        updateConnectionStatus(false, 'reconnecting', attemptNumber);
      });
      
      socket.on('reconnect_failed', () => {
        console.error(`√âchec de reconnexion apr√®s ${maxReconnectAttempts} tentatives`);
        updateConnectionStatus(false, 'failed');
      });
      
      socket.on('error', (error) => {
        console.error('Erreur Socket.IO:', error);
        updateConnectionStatus(false, 'error');
      });
    }
    
    // Nouvelle fonction am√©lior√©e pour g√©rer l'affichage en temps r√©el des nouveaux blocs
    function handleRealtimeNewBlock(block) {
      console.log('Traitement du bloc en temps r√©el:', block);
      
      try {
        // Charger la blockchain actuelle pour d√©terminer le bon index
        const currentBlockchain = JSON.parse(localStorage.getItem('blockchain') || '[]');
        
        // V√©rifier si ce bloc existe d√©j√† par hash (crit√®re unique)
        const existingBlockByHash = document.querySelector(`.block[data-hash="${block.hash}"]`);
        if (existingBlockByHash) {
          console.log(`Le bloc avec hash ${block.hash.substring(0,8)}... existe d√©j√†, pas besoin de l'ajouter √† nouveau`);
          return;
        }
        
        // D√©terminer l'index correct pour ce bloc
        block.index = currentBlockchain.length;
        
        // Cr√©er une notification de nouveau bloc
        showBlockNotification(block);
        
        // Ajouter le bloc √† la visualisation avec classe sp√©ciale pour animation en temps r√©el
        addRealtimeBlockToVisualizer(block);
        
        // Mise √† jour des statistiques
        updateStats();
        
        // Enregistrer le bloc dans localStorage
        saveBlockLocally(block);
        
        // V√©rifier les connexions apr√®s l'ajout
        setTimeout(checkBlockConnections, 500);
      } catch (error) {
        console.error('Erreur lors du traitement du nouveau bloc en temps r√©el:', error);
      }
    }
    
    // Nouvelle fonction pour ajouter un bloc en temps r√©el avec animation sp√©ciale
    function addRealtimeBlockToVisualizer(block) {
      const blockchainContainer = document.getElementById('blockchain');
      
      // Cr√©er l'√©l√©ment de bloc avec la m√™me structure que addBlockToVisualizer
      const blockElement = document.createElement('div');
      blockElement.className = 'block realtime-new'; // Ajouter classe sp√©ciale pour animation
      blockElement.setAttribute('data-index', block.index);
      blockElement.setAttribute('data-hash', block.hash);
      blockElement.setAttribute('data-prev-hash', block.previousHash);
      blockElement.setAttribute('id', `block-${block.index}`);
      
      // D√©terminer si c'est un bloc de gen√®se
      const isGenesis = block.index === 0;
      
      // Structure HTML identique √† la fonction addBlockToVisualizer
      // (La m√™me structure que dans la fonction addBlockToVisualizer)
      
      // Calculer le nombre de transactions
      const txCount = block.transactions ? block.transactions.length : 0;
      
      // Trouver la transaction coinbase et calculer la r√©compense
      let reward = 0;
      if (block.transactions && block.transactions.length > 0) {
        // Chercher la transaction coinbase (premi√®re transaction ou marqu√©e coinbase)
        const coinbaseTx = block.transactions.find(tx => 
          tx.coinbase === true || tx.from === 'COINBASE' || 
          // Aussi v√©rifier la premi√®re transaction si aucune n'est explicitement marqu√©e
          (tx === block.transactions[0] && (tx.from === 'COINBASE' || tx.from === 'R√©compense'))
        );
        
        if (coinbaseTx) {
          reward = parseFloat(coinbaseTx.amount || "0");
          if (!isGenesis && (reward === 0 || isNaN(reward)) && block.index > 0) {
            reward = 50;
          }
        } else if (!isGenesis && block.index > 0) {
          reward = 50;
        }
      }
      
      // Badge pour le nombre de transactions
      if (txCount > 0) {
        blockElement.innerHTML += `<div class="block-badge">${txCount}</div>`;
      }
      
      // Ligne connectant au bloc pr√©c√©dent (sauf pour genesis)
      if (!isGenesis) {
        blockElement.innerHTML += `<div class="block-connect"></div>`;
      }
      
      // En-t√™te du bloc avec informations essentielles
      blockElement.innerHTML += `
        <div class="block-header">
          <div class="block-title">
            <div class="block-index">Bloc #${block.index}</div>
            <div class="block-timestamp">${new Date(block.timestamp).toLocaleDateString()} ${new Date(block.timestamp).toLocaleTimeString()}</div>
          </div>
          
          <div class="hash-container">
            <span class="hash-label">Hash</span>
            <div class="hash-preview">${block.hash.substring(0, 20)}...</div>
          </div>
        </div>
        
        <div class="block-summary">
          <div class="summary-item">
            <div class="summary-value">${txCount}</div>
            <div class="summary-label">Transactions</div>
          </div>
          <div class="summary-item">
            <div class="summary-value">${reward} ‚Ç¨</div>
            <div class="summary-label">R√©compense</div>
          </div>
        </div>
        
        <div class="expand-indicator">Cliquez pour voir les d√©tails</div>
          
          <div class="block-content">
            <div class="hash-container">
              <span class="hash-label">Hash complet</span>
              <div class="hash-value">${block.hash}</div>
            </div>
            
            <div class="hash-container">
              <span class="hash-label">Hash pr√©c√©dent</span>
              <div class="hash-value prev-hash-value" onclick="event.stopPropagation(); highlightBlock('${block.previousHash}')">${block.previousHash}</div>
            </div>
            
            <div class="hash-container">
              <span class="hash-label">Nonce</span>
              <div class="hash-value">${block.nonce || 0}</div>
            </div>
            
            <div class="transactions-label">Transactions (${txCount})</div>
            <div class="transactions-list">
          `;
          
          // Ajouter les transactions
          if (block.transactions && block.transactions.length > 0) {
            block.transactions.forEach(tx => {
              const isCoinbase = tx.coinbase || tx.from === "COINBASE";
              
              blockElement.querySelector('.transactions-list').innerHTML += `
                <div class="transaction ${isCoinbase ? 'coinbase' : ''}">
                  ${isCoinbase ? 
                    `<div class="transaction-details">
                      <span>R√©compense de minage</span>
                      <span>${tx.amount} ‚Ç¨</span>
                    </div>
                    <div>‚Üí ${formatAddress(tx.to)}</div>` : 
                    `<div class="transaction-details">
                      <span>Transfert</span>
                      <span>${tx.amount} ‚Ç¨ + ${tx.fee || '0'} ‚Ç¨ frais</span>
                    </div>
                    <div>${formatAddress(tx.from)} ‚Üí ${formatAddress(tx.to)}</div>`
                  }
                </div>
              `;
            });
          } else {
            blockElement.querySelector('.transactions-list').innerHTML = `<p>Aucune transaction dans ce bloc</p>`;
          }
          
          // Ajouter le Merkle Root dans la section d√©tails du bloc
          blockElement.querySelector('.block-content').innerHTML += `
            <div class="hash-container">
              <span class="hash-label">Merkle Root</span>
              <div class="hash-value">${block.merkleRoot || "Non disponible"}</div>
            </div>
          `;
          
          blockElement.innerHTML += `</div>`;
          
          // Ajouter l'√©v√©nement de clic pour √©tendre/r√©duire
          blockElement.addEventListener('click', function() {
            toggleBlockDetails(this);
          });
          
          // Ajouter le bloc au d√©but du conteneur
          if (blockchainContainer.firstChild) {
            blockchainContainer.insertBefore(blockElement, blockchainContainer.firstChild);
          } else {
            blockchainContainer.appendChild(blockElement);
          }
          
          // Faire d√©filer vers le nouveau bloc avec une animation fluide
          blockElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          
          return blockElement;
        }
        
        // Fonction pour sauvegarder le bloc dans localStorage
        function saveBlockLocally(block) {
          try {
            const blockchainData = localStorage.getItem('blockchain');
            let blockchain = blockchainData ? JSON.parse(blockchainData) : [];
            
            // V√©rifier si le bloc existe d√©j√†
            const blockExists = blockchain.some(existingBlock => existingBlock.hash === block.hash);
            
            if (!blockExists) {
              // Assurer que l'index est correct
              block.index = blockchain.length;
              
              // Ajouter le bloc
              blockchain.push(block);
              localStorage.setItem('blockchain', JSON.stringify(blockchain));
              console.log(`Bloc #${block.index} sauvegard√© dans localStorage`);
            }
          } catch (error) {
            console.error("Erreur lors de la sauvegarde du bloc:", error);
          }
        }
        
        // Fonction pour afficher une notification pour le nouveau bloc
        function showBlockNotification(block) {
          // Cr√©er l'√©l√©ment de notification
          let notification = document.getElementById('block-notification');
          if (!notification) {
            notification = document.createElement('div');
            notification.id = 'block-notification';
            notification.className = 'toast-notification';
            
            notification.innerHTML = `
              <div class="toast-icon">üß±</div>
              <div class="toast-content">
                <div class="toast-title">Nouveau bloc re√ßu</div>
                <div class="toast-message" id="toast-message"></div>
              </div>
            `;
            
            document.body.appendChild(notification);
          }
          
          // Mettre √† jour le contenu
          const messageEl = document.getElementById('toast-message');
          if (messageEl) {
            messageEl.textContent = `Bloc #${block.index} avec ${block.transactions?.length || 0} transactions vient d'√™tre ajout√© √† la blockchain`;
          }
          
          // Afficher la notification
          notification.classList.add('show');
          
          // Cacher la notification apr√®s 5 secondes
          setTimeout(() => {
            notification.classList.remove('show');
          }, 5000);
        }
        
        // Modifier la fonction setupAutoRefresh pour √™tre plus efficace
        function setupAutoRefresh() {
          // V√©rification p√©riodique de la connexion avec le serveur
          setInterval(() => {
            if (connected) {
              // Heartbeat pour v√©rifier la latence et maintenir la connexion
              socket.emit('heartbeat', (response) => {
                const latency = new Date() - new Date(response.serverTime);
                console.log(`Connexion au serveur: OK (latence ${latency}ms)`);
              });
            }
          }, 30000); // Toutes les 30 secondes
          
          // V√©rification locale des blocs dans localStorage moins fr√©quente
          setInterval(() => {
            try {
              const blockchainData = localStorage.getItem('blockchain');
              if (!blockchainData) return;
              
              const blockchain = JSON.parse(blockchainData);
              const displayedBlockCount = document.querySelectorAll('.block').length;
              
              // Si le nombre de blocs dans localStorage est diff√©rent du nombre affich√©,
              // ajouter uniquement les blocs manquants sans recharger toute la page
              if (blockchain.length > displayedBlockCount) {
                console.log(`${blockchain.length - displayedBlockCount} nouveau(x) bloc(s) d√©tect√©(s) en stockage local`);
                
                // Identifier les blocs manquants
                const displayedHashes = Array.from(document.querySelectorAll('.block'))
                  .map(el => el.getAttribute('data-hash'));
                
                // Ajouter uniquement les blocs manquants
                blockchain.forEach(block => {
                  if (!displayedHashes.includes(block.hash)) {
                    console.log(`Ajout du bloc local #${block.index} (${block.hash.substring(0, 8)}...)`);
                    handleRealtimeNewBlock(block, false); // false = pas d'animation
                  }
                });
                
                // Mettre √† jour les statistiques
                updateStats();
              }
            } catch (error) {
              console.error("Erreur lors de la v√©rification auto-refresh:", error);
            }
          }, 5000); // Toutes les 5 secondes
        }

    // Fonction pour synchroniser manuellement la blockchain avec le r√©seau
    function syncBlockchain() {
      if (!connected || !socket) {
        showNotification("Impossible de synchroniser: non connect√© au serveur");
        return;
      }
      
      showNotification("Synchronisation avec le r√©seau en cours...");
      
      // Charger la blockchain locale
      const localBlockchain = JSON.parse(localStorage.getItem('blockchain') || '[]');
      
      // Demander la blockchain du serveur
      socket.emit('requestFullBlockchain', { clientId: socket.id }, function(response) {
        if (response && Array.isArray(response.blockchain)) {
          console.log(`Blockchain du serveur re√ßue: ${response.blockchain.length} blocs`);
          
          // Fusionner les blockchains
          const mergedChain = mergeBlockchains(localBlockchain, response.blockchain);
          
          // Sauvegarder la blockchain fusionn√©e
          localStorage.setItem('blockchain', JSON.stringify(mergedChain));
          
          // Afficher la nouvelle blockchain
          loadRealBlockchain();
          
          showNotification(`Synchronisation termin√©e, blockchain mise √† jour avec ${mergedChain.length} blocs`);
        } else {
          showNotification("√âchec de la synchronisation: blockchain invalide re√ßue du serveur");
        }
      });
      
      // Partager notre blockchain avec le serveur
      socket.emit('shareMyBlockchain', localBlockchain);
    }
    
    // Fonction pour fusionner deux blockchains (locale et distante)
    function mergeBlockchains(localChain, remoteChain) {
      if (!Array.isArray(localChain)) localChain = [];
      if (!Array.isArray(remoteChain)) remoteChain = [];
      
      console.log(`Fusion des blockchains: locale (${localChain.length} blocs) et distante (${remoteChain.length} blocs)`);
      
      // Si la cha√Æne locale est vide, utiliser la cha√Æne distante
      if (localChain.length === 0) return remoteChain;
      
      // Si la cha√Æne distante est vide, conserver la cha√Æne locale
      if (remoteChain.length === 0) return localChain;
      
      // D√©terminer quelle cha√Æne est la plus longue (r√®gle de consensus)
      if (remoteChain.length > localChain.length) {
        console.log(`La cha√Æne distante est plus longue: ${remoteChain.length} > ${localChain.length} blocs`);
        
        // V√©rifier si la cha√Æne distante est valide avant de l'adopter
        if (isValidBlockchain(remoteChain)) {
          console.log("La cha√Æne distante est valide, elle remplace notre cha√Æne locale");
          return repairBlockchainData(remoteChain); // Assurer la coh√©rence des index
        } else {
          console.log("La cha√Æne distante est invalide, on conserve notre cha√Æne locale");
          return localChain;
        }
      } else {
        // Chercher les nouveaux blocs √† int√©grer
        const mergedChain = [...localChain];
        let newBlocksAdded = 0;
        
        remoteChain.forEach(remoteBlock => {
          // V√©rifier si ce bloc existe d√©j√† dans notre cha√Æne
          const blockExists = mergedChain.some(localBlock => localBlock.hash === remoteBlock.hash);
          
          if (!blockExists) {
            // Si le bloc n'existe pas mais a un hash pr√©c√©dent valide,
            // on peut l'ajouter √† la cha√Æne fusionn√©e
            const validPrevHash = mergedChain.some(localBlock => localBlock.hash === remoteBlock.previousHash);
            
            if (validPrevHash) {
              console.log(`Ajout du bloc distant #${remoteBlock.index} (hash: ${remoteBlock.hash.substring(0, 8)}...)`);
              mergedChain.push(remoteBlock);
              newBlocksAdded++;
            }
          }
        });
        
        console.log(`${newBlocksAdded} nouveaux blocs ajout√©s √† notre cha√Æne locale`);
        
        // R√©parer les index apr√®s la fusion
        return repairBlockchainData(mergedChain);
      }
    }
    
    // Fonction pour v√©rifier la validit√© d'une blockchain
    function isValidBlockchain(chain) {
      // Une cha√Æne vide est consid√©r√©e comme valide
      if (chain.length === 0) return true;
      
      // V√©rifier chaque bloc
      for (let i = 1; i < chain.length; i++) {
        const currentBlock = chain[i];
        const previousBlock = chain[i-1];
        
        // 1. V√©rifier que le previousHash pointe vers le hash du bloc pr√©c√©dent
        if (currentBlock.previousHash !== previousBlock.hash) {
          console.log(`Blockchain invalide: le hash pr√©c√©dent du bloc #${i} ne correspond pas au hash du bloc #${i-1}`);
          return false;
        }
        
        // 2. V√©rifier que le hash du bloc est correct (optionnel, plus complexe)
        // Cette v√©rification n√©cessiterait de recalculer le hash
        
        // 3. V√©rifier la s√©quence des index (peut √™tre r√©par√© automatiquement)
        if (currentBlock.index !== i) {
          console.log(`Avertissement: s√©quence d'index incorrecte dans la blockchain`);
          // On ne rejette pas la cha√Æne pour cette raison car elle peut √™tre r√©par√©e
        }
      }
      
      return true;
    }
  </script>
</body>
</html>
